include * @src.GIM
include * @src.byteReader

transpile2C(GismoInstructions instr) txt {
	code := ""

	code += "#include <stdio.h>\n"
	code += "#include <stdint.h>\n"
	code += "#include <stdlib.h>\n\n"
	code += collectConstants(instr)

	return code
}

collectConstants(GismoInstructions instr) txt {
	reader := ByteReader(instr.bytecode, 0)

	num8s is txt[]
	num16s is txt[]
	num32s is txt[]
	num64s is txt[]
	texts  is txt[]
	protos is txt[]
	funcs  is txt[]

	functionCount is ulong = 0
	for reader.hasNext() {
		// output(reader.count, "/", reader.buffer.Length())
		// progressbar@std(" transpilation ", reader.count, reader.buffer.Length(), 100)
		instruction := reader.next()
		if instruction == 0 {
			// NOP
		} else if instruction == 1 {
			// Num8
			num8s.Add(reader.next().fmt())
		} else if instruction == 2 {
			// Num16
			num16s.Add(reader.nextUShort().fmt())
		} else if instruction == 3 {
			// Num32
			num32s.Add(reader.nextUInt().fmt())
		} else if instruction == 4 {
			// Num64
			num64s.Add(reader.nextULong().fmt())
		} else if instruction == 5 {
			// Text
			texts.Add(StringRepresentation@std(reader.nextBuffer()))
		} else if instruction == 6 || instruction == 7 {
			// Function
			local_num8 := reader.nextUInt()
			local_num16 := reader.nextUInt()
			local_num32 := reader.nextUInt()
			local_num64 := reader.nextUInt()
			local_func := reader.nextUInt()
			local_text := reader.nextUInt()
			local_cmplx := reader.nextUInt()
			instructions := reader.nextBuffer()

			transpile2StatementsResult := transpile2Statements(instructions, functionCount)
			cStatements := transpile2StatementsResult.statements
			functionName := transpile2StatementsResult.functionName

			protos.Add("void " + "$function".fmt(functionCount) + "(void); /* " + functionName.replace@std("*", "multi") + " */")
			funcs.Add("void " + "$function".fmt(functionCount) + "(void) {/* " + functionName.replace@std("*", "multi") + " */" + "\n" + cStatements + "\n}")
			functionCount += 1
		}
	}

	code := ""
	code += makeString@std(protos, "\n") + "\n"
	code += "const uint8_t  const_num8["+instr.constNum8Size.fmt()+"] = {"+makeString@std(num8s, ",\n")+"};\n"
	code += "const uint16_t const_num16["+instr.constNum16Size.fmt()+"] = {"+makeString@std(num16s, ",\n")+"};\n"
	code += "const uint32_t const_num32["+instr.constNum32Size.fmt()+"] = {"+makeString@std(num32s, ",\n")+"};\n"
	code += "const uint64_t const_num64["+instr.constNum64Size.fmt()+"] = {"+makeString@std(num64s, ",\n")+"};\n"
	code += "const char *const_text["+instr.constTextSize.fmt()+"] = {"+makeString@std(texts, ",\n")+"};\n"
	code += "\n"
	code += "uint8_t global_num8[" + instr.globalNum8Size.fmt() + "];\n"
	code += "uint16_t global_num16[" + instr.globalNum16Size.fmt() + "];\n"
	code += "uint32_t global_num32[" + instr.globalNum32Size.fmt() + "];\n"
	code += "uint64_t global_num64[" + instr.globalNum64Size.fmt() + "];\n"
	code += "char *global_text[" + instr.globalTextSize.fmt() + "];\n"
	code += "void *global_func[" + instr.globalFuncSize.fmt() + "];\n"
	code += "void *global_cmplx[" + instr.globalCmplxSize.fmt() + "];\n"
	code += makeString@std(funcs, "\n") + "\n"

	return code
}

Transpile2StatementsResult(txt statements, txt functionName) struct;
transpile2Statements(txt instructions, ulong functionCount) Transpile2StatementsResult {
	functionName := "$function".fmt(functionCount)
	fReader := ByteReader(instructions, 0)

	// statements is txt[]
	stack is txt[]

	for fReader.hasNext() {
		fInstr := fReader.next()
		name := bytecode_name@bytecode[fInstr]
		len := bytecode_arglen@bytecode[fInstr]
		
		if fInstr == 1 { // LoadConstNum8
			stack.Add(fmt("const_num8[", fReader.nextUInt(), "]"))
		} else if fInstr == 2 { // LoadConstNum16
			stack.Add(fmt("const_num16[", fReader.nextUInt(), "]"))
		} else if fInstr == 3 { // LoadConstNum32
			stack.Add(fmt("const_num32[", fReader.nextUInt(), "]"))
		} else if fInstr == 4 { // LoadConstNum64
			stack.Add(fmt("const_num64[", fReader.nextUInt(), "]"))
		} else if fInstr == 5 { // LoadConstText
			stack.Add(fmt("const_text[", fReader.nextUInt(), "]"))
		} else if fInstr == 6 { // LoadGlobalNum8
			stack.Add(fmt("global_num8[", fReader.nextUInt(), "]"))
		} else if fInstr == 7 { // LoadGlobalNum16
			stack.Add(fmt("global_num16[", fReader.nextUInt(), "]"))
		} else if fInstr == 8 { // LoadGlobalNum32
			stack.Add(fmt("global_num32[", fReader.nextUInt(), "]"))
		} else if fInstr == 9 { // LoadGlobalNum64
			stack.Add(fmt("global_num64[", fReader.nextUInt(), "]"))
		} else if fInstr == 10 { // LoadGlobalText
			stack.Add(fmt("global_text[", fReader.nextUInt(), "]"))
		} else if fInstr == 11 { // LoadGlobalFunc
			stack.Add(fmt("global_func[", fReader.nextUInt(), "]"))
		} else if fInstr == 12 { // LoadGlobalCmplx
			stack.Add(fmt("global_cmplx[", fReader.nextUInt(), "]"))
		} else if fInstr == 149 {
			// Hint
			hint := fReader.nextBuffer()
			hint_args is split@std(hint, ";")
			if hint_args[0u].cmp@std("fl") {
				functionName = hint_args[1u]
			}
		} else {
			if len == (-1) {
				fReader.nextBuffer()
			} else if len == 2 {
				fReader.nextUShort()
			} else if len == 4 {
				fReader.nextUInt()
			}
		}
	}
	return Transpile2StatementsResult(makeString@std(stack, ";\n"), functionName)
}