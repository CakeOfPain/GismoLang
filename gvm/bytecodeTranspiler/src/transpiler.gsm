include * @src.GIM
include * @src.byteReader

transpile2C(GismoInstructions instr) txt {
	code := ""

	code += "#include <stdio.h>\n"
	code += "#include <stdint.h>\n"
	code += "#include <stdlib.h>\n\n"
	code += "#define GVM_ZZE(I) ((((int64_t) I) >> 63) ^ (((int64_t) I) << 1))\n"
	code += "#define GVM_ZZD(I) ((((int64_t) I) >> 1) ^ -(((int64_t) I) & 1))\n"
	code += "#define GVM_U2I(X) ({uint64_t x = X;GVM_ZZE(*((int64_t*) &x));})\n"
	code += "#define GVM_U2F(X) ({uint64_t x = X;*((double*) &x);})\n"
	code += "#define GVM_I2U(X) ({int64_t x = GVM_ZZD(X);*((uint64_t*) &x);})\n"
	code += "#define GVM_I2F(X) ({int64_t x = GVM_ZZD(X);*((double*) &x);})\n"
	code += "#define GVM_F2U(X) ({double x = X;*((uint64_t*) &x);})\n"
	code += "#define GVM_F2I(X) ({double x = X;GVM_ZZE(*((uint64_t*) &x));})\n\n"
	code += collectConstants(instr)

	return code
}

collectConstants(GismoInstructions instr) txt {
	reader := ByteReader(instr.bytecode, 0)

	num8s is txt[]
	num16s is txt[]
	num32s is txt[]
	num64s is txt[]
	texts  is txt[]
	protos is txt[]
	funcs  is txt[]

	functionCount is ulong = 0
	for reader.hasNext() {
		// output(reader.count, "/", reader.buffer.Length())
		// progressbar@std(" transpilation ", reader.count, reader.buffer.Length(), 100)
		instruction := reader.next()
		if instruction == 0 {
			// NOP
		} else if instruction == 1 {
			// Num8
			num8s.Add(reader.next().fmt())
		} else if instruction == 2 {
			// Num16
			num16s.Add(reader.nextUShort().fmt())
		} else if instruction == 3 {
			// Num32
			num32s.Add(reader.nextUInt().fmt())
		} else if instruction == 4 {
			// Num64
			num64s.Add(reader.nextULong().fmt())
		} else if instruction == 5 {
			// Text
			texts.Add(StringRepresentation@std(reader.nextBuffer()))
		} else if instruction == 6 || instruction == 7 {
			// Function
			local_num8 := reader.nextUInt()
			local_num16 := reader.nextUInt()
			local_num32 := reader.nextUInt()
			local_num64 := reader.nextUInt()
			local_func := reader.nextUInt()
			local_text := reader.nextUInt()
			local_cmplx := reader.nextUInt()
			instructions := reader.nextBuffer()

			transpile2StatementsResult := transpile2Statements(instructions, functionCount)
			cStatements := transpile2StatementsResult.statements
			functionName := transpile2StatementsResult.functionName

			protos.Add("void " + "$function".fmt(functionCount) + "(void); /* " + functionName.replace@std("*", "multi") + " */")
			funcs.Add(fmt(
				"void ",
				"$function".fmt(functionCount),
				"(void) {/* ",
				functionName.replace@std("*", "multi"),
				" */",
				"\n",
				"uint8_t local_num8[", local_num8, "];\n",
				"uint16_t local_num16[", local_num16, "];\n",
				"uint32_t local_num32[", local_num32, "];\n",
				"uint64_t local_num64[", local_num64, "];\n",
				"char *local_text[", local_text, "];\n",
				"void *local_func[", local_func, "];\n",
				"void *local_cmplx[", local_cmplx, "];\n",
				cStatements,
				"\n}"
			))
			functionCount += 1
		}
	}

	code := ""
	code += makeString@std(protos, "\n") + "\n"
	code += "const uint8_t  const_num8["+instr.constNum8Size.fmt()+"] = {"+makeString@std(num8s, ",\n")+"};\n"
	code += "const uint16_t const_num16["+instr.constNum16Size.fmt()+"] = {"+makeString@std(num16s, ",\n")+"};\n"
	code += "const uint32_t const_num32["+instr.constNum32Size.fmt()+"] = {"+makeString@std(num32s, ",\n")+"};\n"
	code += "const uint64_t const_num64["+instr.constNum64Size.fmt()+"] = {"+makeString@std(num64s, ",\n")+"};\n"
	code += "const char *const_text["+instr.constTextSize.fmt()+"] = {"+makeString@std(texts, ",\n")+"};\n"
	code += "\n"
	code += "uint8_t global_num8[" + instr.globalNum8Size.fmt() + "];\n"
	code += "uint16_t global_num16[" + instr.globalNum16Size.fmt() + "];\n"
	code += "uint32_t global_num32[" + instr.globalNum32Size.fmt() + "];\n"
	code += "uint64_t global_num64[" + instr.globalNum64Size.fmt() + "];\n"
	code += "char *global_text[" + instr.globalTextSize.fmt() + "];\n"
	code += "void *global_func[" + instr.globalFuncSize.fmt() + "];\n"
	code += "void *global_cmplx[" + instr.globalCmplxSize.fmt() + "];\n\n"
	code += makeString@std(funcs, "\n") + "\n"

	return code
}

Transpile2StatementsResult(txt statements, txt functionName) struct;
transpile2Statements(txt instructions, ulong functionCount) Transpile2StatementsResult {
	functionName := "$function".fmt(functionCount)
	fReader := ByteReader(instructions, 0)

	statements is txt[]
	stack is txt[]

	for fReader.hasNext() {
		fInstr := fReader.next()
		name := bytecode_name@bytecode[fInstr]
		len := bytecode_arglen@bytecode[fInstr]
		top := stack.Size() - 1
		
		if fInstr == 1 { 
			// LoadConstNum8(index: num32)() -> num8
			stack.Add(fmt("const_num8[", fReader.nextUInt(), "]"))
		} else if fInstr == 2 {
			// LoadConstNum16(index: num32)() -> num16
			stack.Add(fmt("const_num16[", fReader.nextUInt(), "]"))
		} else if fInstr == 3 {
			// LoadConstNum32(index: num32)() -> num32
			stack.Add(fmt("const_num32[", fReader.nextUInt(), "]"))
		} else if fInstr == 4 {
			// LoadConstNum64(index: num32)() -> num64
			stack.Add(fmt("const_num64[", fReader.nextUInt(), "]"))
		} else if fInstr == 5 {
			// LoadGlobalNum8(index: num32)() -> num8
			stack.Add(fmt("global_num8[", fReader.nextUInt(), "]"))
		} else if fInstr == 6 {
			// LoadGlobalNum16(index: num32)() -> num16
			stack.Add(fmt("global_num16[", fReader.nextUInt(), "]"))
		} else if fInstr == 7 {
			// LoadGlobalNum32(index: num32)() -> num32
			stack.Add(fmt("global_num32[", fReader.nextUInt(), "]"))
		} else if fInstr == 8 {
			// LoadGlobalNum64(index: num32)() -> num64
			stack.Add(fmt("global_num64[", fReader.nextUInt(), "]"))
		} else if fInstr == 9 && stack.Size() > 0 {
			// StoreGlobalNum8(index: num32)(value: num8) -> none
			statements.Add(fmt("global_num8[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 10 && stack.Size() > 0 {
			// StoreGlobalNum16(index: num32)(value: num16) -> none
			statements.Add(fmt("global_num16[",fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 11 && stack.Size() > 0 {
			// StoreGlobalNum32(index: num32)(value: num32) -> none
			statements.Add(fmt("global_num32[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 12 && stack.Size() > 0 {
			// StoreGlobalNum64(index: num32)(value: num64) -> none
			statements.Add(fmt("global_num64[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 13 {
			// LoadLocalNum8(index: num32)() -> num8
			stack.Add(fmt("global_num8[", fReader.nextUInt(), "]"))
		} else if fInstr == 14 {
			// LoadLocalNum16(index: num32)() -> num16
			stack.Add(fmt("global_num16[", fReader.nextUInt(), "]"))
		} else if fInstr == 15 {
			// LoadLocalNum32(index: num32)() -> num32
			stack.Add(fmt("global_num32[", fReader.nextUInt(), "]"))
		} else if fInstr == 16 {
			// LoadLocalNum64(index: num32)() -> num64
			stack.Add(fmt("global_num64[", fReader.nextUInt(), "]"))
		} else if fInstr == 17 && stack.Size() > 0 {
			// StoreLocalNum8(index: num32)(value: num8) -> none
			statements.Add(fmt("local_num8[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 18 && stack.Size() > 0 {
			// StoreLocalNum16(index: num32)(value: num16) -> none
			statements.Add(fmt("local_num16[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 19 && stack.Size() > 0 {
			// StoreLocalNum32(index: num32)(value: num32) -> none
			statements.Add(fmt("local_num32[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 20 && stack.Size() > 0 {
			// StoreLocalNum64(index: num32)(value: num64) -> none
			statements.Add(fmt("local_num64[", fReader.nextUInt(), "] = ", stack.Remove(top), ";"))
		} else if fInstr == 21 && stack.Size() > 1 {
			// AddI()(a: int, b: int) -> int
			a = stack.Remove(top)
			b = stack.Remove(top-1)
			stack.Add("(GVM_I2U(GVM_U2I("+a+") + GVM_U2I("+b+")))")
		} else if fInstr == 22 && stack.Size() > 1 {
			// AddU()(a: uint, b: uint) -> uint
			a = stack.Remove(top)
			b = stack.Remove(top-1)
			stack.Add("("+a+" + "+b+")")
		} else if fInstr == 22 && stack.Size() > 1 {
			// AddF()(a: double, b: double) -> double
			a = stack.Remove(top)
			b = stack.Remove(top-1)
			stack.Add("(GVM_F2U(GVM_U2F("+a+") + GVM_U2F("+b+")))")
		} else if fInstr == 149 {
			// Hint
			hint := fReader.nextBuffer()
			hint_args is split@std(hint, ";")
			if hint_args[0u].cmp@std("fl") {
				functionName = hint_args[1u]
			}
		} else {
			if len == (-1) {
				fReader.nextBuffer()
			} else if len == 2 {
				fReader.nextUShort()
			} else if len == 4 {
				fReader.nextUInt()
			}
		}
	}
	return Transpile2StatementsResult(makeString@std(statements, "\n"), functionName)
}